# Reading Materials

[**A Dialogue on Virtualization**](https://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf)
[**The Abstraction: The Process**](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf)
[**Interlude: Process API**](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf)
[**Mechanism: Limited Direct Execution**](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf)

---
# The Abstraction: The Process
- **Definition of a Process:**
	- A process is simply a running program.
	- Programs are static, lifeless entities sitting on disk as instructions and data.
	- The operating system (OS) is responsible for transforming these bytes into a running, useful process.
- **Importance of Processes:**
    - Users often want to run multiple programs simultaneously (e.g., web browser, mail, games).
    - Modern systems can run tens or even hundreds of processes at the same time.
    - This ability enhances system usability, making it easy to run multiple programs without worrying about CPU availability.
- **Virtualization of the CPU**    
    - The OS creates the illusion of many virtual CPUs from one or a few physical CPUs.
    - Achieved through **time-sharing**: the OS rapidly switches between processes, giving the appearance that multiple processes are running concurrently.
- **Benefits of CPU Virtualization:**
    - Allows users to run as many concurrent processes as they like.
    - Provides a seamless experience where users don't need to manage CPU resources manually.
- **Trade-off:** 
    - The potential cost of time-sharing is performance degradation.
    - As more processes share the CPU, each process may run slower.
- **Mechanisms:**
    - **Definition:** Low-level methods or protocols that implement specific OS functionalities.
    - **Example: Context Switching**
        - The process of stopping one program and starting another on a given CPU.
        - Context switching is fundamental to time-sharing and is used by all modern OSes.
- **Policies:**
    - **Definition:** High-level algorithms used to make decisions within the OS.
    - **Example: Scheduling Policy**
        - Determines which process to run on a CPU at any given time.
        - Factors in decision-making:
            - **Historical Information:** How much has a program run recently?
            - **Workload Knowledge:** What types of programs are running?
            - **Performance Metrics:** Is the system prioritizing interactive performance or throughput?
---
## 4.1 - The Abstraction: A Process
### Definition of a Process
- A **process** is the OS’s abstraction of a running program.
- It represents the program's execution state at any given time.
### Components of a Process's Machine State
-  **Instructions and Data:** The instructions executed by the program and the data it reads or writes reside in memory.
- **Address Space:** The memory that a process can access is referred to as its **address space**.
- **Registers:**
    - **General Purpose Registers:** Registers are small, fast storage locations in the CPU that the process frequently accesses or updates during execution.
    - **Special Registers:**
        - **Program Counter (PC):** Also known as the **Instruction Pointer (IP)**, this register holds the address of the next instruction to execute.
        - **Stack Pointer and Frame Pointer:** These registers manage the stack, which is used for storing function parameters, local variables, and return addresses during function calls.
- **I/O Information:**
    - **Persistent Storage Devices:** The process may interact with persistent storage (e.g., hard drives, SSDs).
    - **Open Files:** The process’s I/O state includes a list of files that it currently has open for reading or writing.
---
## 4.2 - Process API
### Process API
- The **Process API** is the set of functions or system calls provided by the OS to manage and interact with processes.

### Key Components of a Process API
- **Create:** Provides a method to create new processes.
	- When a user types a command in a shell or double-clicks an application, the OS creates a new process to execute the specified program.
- **Destroy:** Allows forceful termination of processes.
	- Users can kill processes that are not terminating on their own, especially useful for stopping runaway or unresponsive processes.
- **Wait:** Enables a process to wait for another process to finish execution.
	- A parent process might wait for its child process to complete before continuing.
- **Miscellaneous Control:** Some APIs allow processes to be suspended (paused) and then resumed.
	- Suspending a process during heavy CPU usage and resuming it later.
- **Status:** Provides information about a process’s state, such as its runtime or current status.
	- Checking how long a process has been running or whether it is currently active or suspended.
---
## 4.3 - Process Creation: A Little More Detail
### Process Creation
- The process of transforming a program into a running process involves several key steps, managed by the OS.

### Loading the Program into Memory
- **Code and Static Data:** The OS loads the program’s code and static data (e.g., initialized variables) from disk (or SSD) into the process’s address space in memory.
- **Eager Loading:** Early OSes load the entire program into memory before execution.
- **Lazy Loading:** Modern OSes load pieces of code and data as needed during execution, optimizing memory usage.
![[Figure-4.1-Loading.png]]
### Memory Allocation
- **Stack Allocation:**
    - The OS allocates memory for the program's runtime stack, used for local variables, function parameters, and return addresses.
    - **Initialization:** The OS initializes the stack with arguments for the `main()` function, such as `argc` and `argv`.
- **Heap Allocation:** The heap is allocated for dynamically-allocated data structures (e.g., linked lists, trees) that the program may request via `malloc()`.
- **File Descriptors:** In UNIX systems, the OS initializes default file descriptors for standard input, output, and error, facilitating basic I/O operations.
- **Entry Point:** After setting up memory and I/O, the OS starts the program by jumping to its entry point, `main()`, transferring control of the CPU to the new process.
---
## 4.4 - Process States
- A process can be in different states during its lifecycle, depending on what it is doing and how the OS is managing it.
### The Three Primary Process States
- **Running:** The process is actively executing instructions on the CPU.
	- It has been scheduled by the OS and is currently utilizing the processor.
- **Ready:** The process is prepared to run but is not currently executing because the OS has chosen to run another process.
	- It is in a queue, waiting for the CPU to become available.
- **Blocked:** The process is waiting for an external event to occur before it can continue execution.
	- Waiting for I/O operations to complete, such as reading from a disk or waiting for network data.
	- While blocked, the process does not consume CPU resources, allowing other processes to run.
### Transitions Between States
- **Scheduled:** When a process is being moved from ready to running.
	- The OS decides to assign the CPU to a process, moving it from the ready state to the running state.
- **Descheduled:** When a process is being moved from running to ready
	- The OS may preempt the running process and move it back to the ready state, often to give another process a turn to run.
- **Moving to/from Blocked:** 
	- When a process requests I/O, it moves to the blocked state, freeing the CPU for other processes.
	- Once the I/O operation completes, the process becomes ready to run again and may be moved directly to the running state, depending on the OS’s decision.
---
## 4.5 - Data Structures
### Process Tracking in the OS
- **Process List:** The OS maintains a **process list** that includes all processes, particularly those that are ready to run.
	- It also tracks the currently running process.
- **Blocked Processes:** The OS tracks processes that are blocked (e.g., waiting for I/O operations to complete).
    - When an I/O event completes, the OS ensures the correct process is awakened and moved to the ready state.
###  Key Information Tracked by the OS
- **Register Context:** The OS saves the **register context** of a stopped process, which includes the contents of its CPU registers.
    - **Context Switch:** During a context switch, the OS restores these registers to resume the process from where it left off.
- **Process States Beyond Running, Ready, and Blocked:**
    - **Initial State:** A process may be in an initial state during its creation.
    - **Final State (Zombie State):**
        - After a process exits but before it is fully cleaned up, it enters a **zombie state** (in UNIX-based systems).
        - The zombie state allows the parent process to check the return code of the child process to determine if it executed successfully.
        - Typically, a return code of zero indicates success, while a non-zero value indicates an error.
- **Cleaning Up:** The parent process can call `wait()` to wait for the child process to finish and to notify the OS that it can clean up the data structures associated with the now-terminated process.
# Interlude: Process API
- UNIX systems use a unique approach to process creation through a combination of system calls: `fork()`, `exec()`, and `wait()`.
- The design of process creation and control interfaces should balance powerful functionality, ease of use, and high performance.
---
## 5.1 The `fork()` System Call
###  Introduction to `fork()`
- The `fork()` system call is used in UNIX systems to create a new process.
- The newly created process is almost an exact copy of the calling process.
- **Process Duplication:**
    - When `fork()` is called, the OS creates a new process (the **child process**) that is a duplicate of the calling process (the **parent process**).
    - Both the parent and child processes continue execution from the point where `fork()` was called.
- **Key Differences Between Parent and Child:**
    - **PID Return Value:** The parent process receives the PID of the child process as the return value from `fork()`.
        - The child process receives a return value of `0`.
    - **Address Space:** The child process has its own copy of the parent’s address space (memory), meaning it can modify its memory independently of the parent.
### Non-deterministic Behavior of `fork()`
- **Process Scheduling:** After `fork()`, both the parent and child processes are active, but which one runs first is determined by the CPU scheduler.
    - **Non-determinism:** The output of a program using `fork()` can vary between runs because the scheduler’s decision on which process to run first is not predictable.
    - **Implications:** This non-deterministic behavior is particularly important in understanding multi-threaded programs and concurrency issues.
###  CPU Scheduler
- The CPU scheduler decides which process runs at any given moment, affecting the order in which processes execute after a `fork()` call.
- This decision-making process is complex and not easily predictable, leading to varying outcomes in process execution order.
### Example Program (Calling `fork()`)
``` c title:p1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) { 
	printf("hello (pid:%d)\n", (int) getpid());
	int rc = fork();
	if (rc < 0) { 
		// fork failed
		fprintf(stderr, "fork failed\n"); 
		exit(1);
	} else if (rc == 0) { 
		// child (new process)
		printf("child (pid:%d)\n", (int) getpid());
	} else {
		// parent goes down this path (main)
		printf("parent of %d (pid:%d)\n", 18 rc, (int) getpid());
	}
	
	return 0;
}
```
- **Program Behavior:**
	- The program first prints a message with its PID, then calls `fork()`.
	- After `fork()`, both the parent and child processes print messages, but the order of these messages can vary.
---
## 5.2 The `wait()` System Call
###  Introduction to `wait()`
- The `wait()` system call is used by a parent process to pause its execution until a child process has finished executing.
- **`waitpid()`:** A more flexible version of `wait()`, allowing the parent to wait for specific child processes.
- **Process Synchronization:**
    - When a parent process calls `wait()`, it stops executing and waits for its child process to complete.
    - After the child process finishes, `wait()` returns, and the parent process resumes execution.
    - This demonstrates the non-deterministic nature of process scheduling.
### Deterministic Behavior with `wait()`
- **Deterministic Output:** Adding a `wait()` call ensures that the child process always completes and prints its output before the parent process continues.
	- If the parent process happens to run first, it will immediately call `wait()`, causing it to pause until the child process finishes, ensuring the child’s output is always printed before the parent’s.
### Example Program (Calling `fork()` and `wait()`)
```c title:p2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
	printf("hello (pid:%d)\n", (int) getpid());
	int rc = fork();
	if (rc < 0) { 
		// fork failed
		fprintf(stderr, "fork failed\n");
		exit(1);
	} else if (rc == 0) { 
		// child (new process)
		printf("child (pid:%d)\n", (int) getpid());
	} else { 
		// parent goes down this path
		int rc_wait = wait(NULL);
		printf("parent of %d (rc_wait:%d) (pid:%d)\n",
			   rc, rc_wait, (int) getpid());
   }
   
   return 0;
}
```
- **Program Behavior:**
	- - The parent process prints a message, then calls `wait()`.
	- The child process prints its message and exits.
	- The parent process resumes after the child process finishes, resulting in a consistent order of output.
---
## 5.3 Finally, the `exec()` System Call
### Introduction to `exec()`
- The `exec()` system call is used to replace the current process with a new program.
- Unlike `fork()`, which duplicates the calling process, `exec()` transforms the current process into a different one.
- **Functionality:**
	- When a process calls `exec()`, it specifies an executable file and any arguments.
	- The OS loads the new program’s code and static data, overwriting the existing program’s code and data.
	- The process's heap, stack, and memory space are re-initialized for the new program.
	- The process then starts executing the new program with the provided arguments.
- **No New Process:** Unlike `fork()`, `exec()` does not create a new process. It transforms the existing process into a new one, running the specified program.
### Important Characteristics of `exec()`
- **Non-returning Call:** A successful `exec()` call does not return to the original program. If it returns, it indicates an error occurred.
- **Use Case:** `exec()` is typically used after `fork()` when the goal is to run a different program within the child process.
### Example Program (Calling `fork()`, `wait()`, and `exec()`)
```c title:p3.c
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/wait.h>
 
 int main(int argc, char *argv[]) {
	 printf("hello (pid:%d)\n", (int) getpid());
	 int rc = fork();
	 if (rc < 0) { 
		 // fork failed; exit
		 fprintf(stderr, "fork failed\n");
		 exit(1);
	 } else if (rc == 0) { 
		 // child (new process)
		 printf("child (pid:%d)\n", (int) getpid());
		 char *myargs[3];
		 myargs[0] = strdup("wc");   // program: "wc"
		 myargs[1] = strdup("p3.c"); // arg: input file
		 myargs[2] = NULL;           // mark end of array
		 execvp(myargs[0], myargs);  // runs word count
		 printf("this shouldn’t print out");
	 } else { 
		 // parent goes down this path
		 int rc_wait = wait(NULL);
		 printf("parent of %d (rc_wait:%d) (pid:%d)\n", 
			    rc, rc_wait, (int) getpid());
	}
	
	return 0;
}
```
- **Program Behavior:**
	- In this example, after a `fork()`, the child process calls `execvp()` to run the `wc` (word count) program on a file (`p3.c`).
	- The original child process’s code is replaced by the `wc` program, which counts the lines, words, and bytes in `p3.c`.
	- Once `exec()` is called successfully, the previous program (e.g., `p3.c`) is effectively gone, and only the new program (`wc`) continues to run.
---
## 5.4 - Why? Motivating the API
### The Separation of `fork()` and `exec()`
- The separation of `fork()` and `exec()` in UNIX is essential for building a shell, enabling the shell to perform tasks between creating a process and running a program.
- This design allows the shell to modify the environment of the child process before executing a new program, enabling powerful and flexible features.
- The shell is a user program that waits for user input, such as a command, then:
	1. **`fork()`**: Creates a new child process.
	2. **`exec()`**: Replaces the child process's memory with the program specified by the user.
	3. **`wait()`**: The shell waits for the child process to finish before continuing.
	- After the child process completes, the shell prints a new prompt and waits for the next command.
- The `fork()/exec()` combination provides a powerful way to create and manipulate processes, enabling complex behaviors such as output redirection, piping, and environment manipulation.
### UNIX Pipes
- UNIX pipes use the `pipe()` system call to connect the output of one process to the input of another, creating a seamless data flow between commands.
- `grep -o foo file | wc -l`:
	- `grep` searches for "foo" in the file, and its output is piped to `wc -l`, which counts the occurrences.
### Example Program (With Redirection)
```c title:p4.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
	int rc = fork();
	if (rc < 0) {
		// fork failed
		fprintf(stderr, "fork failed\n");
		exit(1);
	} else if (rc == 0) {
		// child: redirect standard output to a file
		close(STDOUT_FILENO);
		open("./p4.output", O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);
		
		// now exec "wc"...
		char *myargs[3];
		myargs[0] = strdup("wc");   // program: wc
		myargs[1] = strdup("p4.c"); // arg: file to count
		myargs[2] = NULL; // mark end of array
		execvp(myargs[0], myargs); // runs word count
	} else {
		// parent goes down this path (main)
		int rc_wait = wait(NULL);
	} 
	
	return 0;
}
```
- **Program Behavior:**
	- Before calling `exec()`, the child process closes the standard output (STDOUT) and opens `newfile.txt`.
	- **File Descriptor Management:** UNIX assigns the lowest available file descriptor (starting from 0). When `open()` is called, it assigns `newfile.txt` to STDOUT.
    - **Result:** Output from the `wc` program is written to `newfile.txt` instead of the screen.
---
## 5.5 - Process Control and Users
- **`kill()` System Call:** Used to send signals to processes, directing them to perform actions like pausing, terminating, or other operations.
###  Signals Subsystem
- **Common Signals:**
	- **SIGINT (Interrupt):** Sent with `control-c`, typically terminates a process.
	- **SIGTSTP (Stop):** Sent with `control-z`, pauses the process, which can be resumed later.
- **Signal Handling:** Processes can use the `signal()` system call to catch specific signals, allowing them to run custom code when a signal is received.
    - **Communication:** Signals allow for communication between processes and the system, as well as between processes and process groups.
### User Permissions and Signal Sending
- **Who Can Send Signals:** Only the user who owns a process can send signals to that process, ensuring security and usability.
- **User Authentication:** Users authenticate by logging in with credentials, gaining control over their own processes (e.g., pausing, killing).
- **System Resource Management:** The OS manages resources like CPU, memory, and disk among users and their processes, maintaining overall system goals.
-----
# Mechanism: Limited Direct Execution
To virtualize the CPU, the operating system (OS) shares the physical CPU among multiple processes by time-sharing. This means that the OS runs one process for a brief period, then switches to another, creating the illusion that all processes are running simultaneously.

However, there are two major challenges in implementing CPU virtualization:

1. **Performance:** The OS must ensure that virtualization does not significantly degrade system performance.
2. **Control:** The OS needs to maintain control over the CPU to prevent processes from monopolizing it or accessing unauthorized resources.

Balancing high performance with effective control is a key challenge in building an efficient operating system.
## 6.1 - Basic Technique - Limited Direct Execution
### Direct Execution
- Direct execution means running a program directly on the CPU without the OS constantly intervening.
- The OS creates a process entry, allocates memory, loads the program code, finds the entry point (e.g., `main()`), and starts running the user’s code.
### Challenges of Direct Execution
- **Problem 1: Lack of Control**:  If a program runs directly on the CPU, the OS loses control over what the program does, risking unauthorized actions or system misuse.
- **Problem 2: Time Sharing**:  The OS needs to implement time-sharing to allow multiple processes to run on the CPU. This requires the ability to stop one process and switch to another.
### Limited Direct Execution
- **Purpose of Limits:**
    - To maintain control, the OS imposes limits on how a program runs.
    - Without these limits, the OS would lose its role as the system’s resource manager and would become "just a library."
---
## 6.2 - Problem #1: Restricted Operations
- **Direct Execution:** Programs run directly on the CPU for high performance, but this raises issues related to control and access to restricted operations like I/O and memory allocation.
- **User Mode vs. Kernel Mode:**
	- **User Mode:** User processes run in this restricted mode and cannot perform privileged operations like I/O or accessing system resources directly.
	- **Kernel Mode:** The OS runs in kernel mode, with full access to hardware and privileged operations.
### System Calls and Traps
- **System Calls:**
    - A mechanism that allows user programs to request services from the OS, such as file access, process creation, and memory allocation.
    - **Trap Instruction:**
        - A special CPU instruction that transfers control to the OS by entering kernel mode.
        - The process’s current state (registers, program counter) is saved to a kernel stack, and the OS handles the system call.
- **System Call Return:**
    - Once the OS finishes executing the system call, a **return-from-trap** instruction is used to return control to the user process and switch the CPU back to user mode.
### Trap Handling
- **Trap Table:**
    - The OS sets up a **trap table** at boot time, which contains addresses of kernel routines for handling events like system calls and interrupts.
    - The trap table ensures that user processes cannot specify their own jump addresses to privileged kernel code.
- **System Call Number:** Each system call is identified by a **system call number**. The user process passes this number, and the OS looks it up in the trap handler to execute the corresponding service.
- **Protection:** User processes cannot jump directly into the kernel. The OS controls which part of the kernel is executed in response to a system call, ensuring security.
- **Restricted Instructions:** Some CPU instructions, like setting the trap table, can only be executed in kernel mode. If attempted in user mode, the system raises an exception, terminating the offending process.
### Protocol Summary
- **Boot Time:** The OS sets up the trap table using privileged instructions.
- **Process Execution:**
    - The OS starts a process in user mode using a return-from-trap instruction.
    - When the process needs privileged services, it triggers a system call, trapping into the kernel.
    - After handling the system call, the OS returns control to the process, switching back to user mode.
----
## 6.3 Problem #2: Switching Between Processes
- **Issue:** When a process runs directly on the CPU, the OS loses control over the system, which makes it difficult to switch between processes.
- **The Crux:** The OS must find a way to **regain control of the CPU** in order to implement process switching and time-sharing.
### Cooperative Process Switching
- **Cooperative Approach:**
    - In early systems (e.g., early Mac OS), processes voluntarily yield control of the CPU by making system calls or using a `yield()` call.
    - **Problems with Cooperation:** If a process enters an infinite loop or fails to make system calls, the OS loses control, requiring a system reboot to regain it.
### Non-Cooperative Process Switching
- **Timer Interrupt:**
    - The solution to non-cooperative processes is a **timer interrupt**, where the OS sets a hardware timer to interrupt the CPU after a set period.
    - When the timer fires, the OS gains control, stopping the current process and allowing it to decide whether to continue the same process or switch to another.
    - **How It Works:** The OS sets up the timer and trap handlers at boot time, and when the interrupt occurs, the OS regains control and can switch processes.
### Saving and Restoring Context (Context Switching)
- **Context Switch:** When switching between processes, the OS saves the current process’s state (registers, program counter, stack pointer) and restores the next process’s state.
    - **Steps:**
        1. **Save Current Context:** The OS saves the general-purpose registers, PC, and kernel stack pointer of the currently running process onto its kernel stack.
        2. **Restore New Context:** The OS restores the saved context of the next process, switching the stack pointer to the next process’s kernel stack.
        3. **Return from Trap:** The OS resumes execution of the next process, returning from the trap handler and switching the CPU to user mode.
### Timer Interrupt Process:
- When the timer interrupt occurs:
	1. The CPU switches to **kernel mode**.
	2. The OS saves the running process’s registers onto its kernel stack.
	3.  The OS decides to switch to a new process, saves the current process’s state, and restores the next process’s state.
### Hardware and Software Responsibilities
- **Hardware Responsibilities:** The hardware saves the current process's state during a timer interrupt (e.g., pushing registers onto the kernel stack).
- **OS Responsibilities:** The OS explicitly saves and restores process states in memory (process structure) during a context switch.
### Example of a Context Switch
1. **Interrupt Occurs:** Process A is running and a timer interrupt occurs, saving its state and switching to kernel mode.
2. **OS Decision:** The OS decides to switch from Process A to Process B.
3. **Switching Context:** The OS saves Process A’s context and restores Process B’s context, including stack pointer and registers.
4. **Return from Trap:** The OS returns control to Process B, which resumes execution in user mode.
----
## 6.4 - Worried about Concurrency?
### Challenge
- Interrupts can occur at any time, even during the handling of another interrupt or while a system call is being processed.
- The OS must manage these overlapping events carefully to maintain system stability and performance.
### Disabling Interrupts
- **Temporary Solution:** The OS may **disable interrupts** during interrupt handling to prevent other interrupts from occurring while one is being processed.
- **Risk:** Disabling interrupts for too long can cause **lost interrupts**, where important events are missed by the system, leading to failures or delays.
### Locking Mechanisms
- **Concurrency Control:** Modern operating systems use **locking schemes** to manage concurrent access to shared data structures within the kernel.
    - These mechanisms are crucial for handling multiple activities in the kernel, especially in **multiprocessor systems** where different processors may be handling different tasks simultaneously.
- **Complexity:** Locking and concurrency mechanisms can be complex and introduce subtle bugs, such as deadlocks or race conditions, which are difficult to detect and fix.
-----
