# Reading Materials
[**Paging: Introduction**](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/vm-paging.pdf)
[**Paging: Faster Translations (TLBs)**](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/vm-tlbs.pdf)
[**Paging: Smaller Tables**](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/vm-smalltables.pdf)

----
# Paging: Introduction
### Two Approaches to Space Management
- **Variable-Sized Allocation (Segmentation):**
    - Divides memory into **variable-sized segments** (e.g., code, heap, stack).
    - **Problem:** This approach can lead to **external fragmentation**, making memory allocation harder over time as free space becomes non-contiguous.
- **Fixed-Sized Allocation (Paging):**
    - **Paging** is the second approach that solves space management problems by dividing memory into **fixed-sized pieces**.
    - Paging avoids fragmentation by dividing both virtual and physical memory into **fixed-sized units**.
### Introduction to Paging
- **Basic Idea:**
    - Paging divides a process's **virtual address space** into **fixed-size units** called **pages**.
    - Correspondingly, **physical memory** is divided into **page frames**, each of which can hold a single virtual page.
- **Key Terms:**
    - **Page:** A fixed-sized block of virtual memory.
    - **Page Frame:** A fixed-sized block of physical memory.
### CRUX: How to Virtualize Memory with Pages
- The challenge in paging is to efficiently manage the mapping between **virtual pages** and **physical page frames**.
- The OS must ensure that paging **minimizes overhead** in both **space** (memory usage for tracking pages) and **time** (time taken to translate virtual addresses to physical addresses).
-----
## 18.1 - A Simple Example And Overview
### Paging Process
- **Advantages of Paging:**
    - **Flexibility:** Pages from the virtual address space can be placed in any available page frame in physical memory, without assumptions about memory layout.
    - **Simplified Memory Management:** OS keeps a list of free page frames and allocates any available frames as needed.
- **Page Table:**  A **per-process** data structure that keeps track of where each **virtual page** is located in **physical memory**.
### Address Translation
- **Virtual Address Breakdown:** The virtual address space is 64 bytes (6 bits), so a virtual address is split into two parts:
	- **Virtual Page Number (VPN):** Top 2 bits for the page number.
	- **Offset:** Bottom 4 bits for the location within the page.
- **Example Translation:**
    - Process tries to load data from **virtual address 21**.
    - Virtual address **21** in binary is `010101`:
        - **VPN = 01** (virtual page 1).
        - **Offset = 0101** (the 5th byte in the page).
    1. The **page table** is consulted to translate VPN 1. The page table indicates that **virtual page 1** is in **physical frame 7**.
    2.  Replace VPN 1 with **PFN 7**.
    3. Combine the **PFN** and the **offset**. The result is the physical address **1110101** (decimal 117).
### Key Concepts
- **Page Table Storage:** The OS stores a page table for each process, mapping virtual pages to physical page frames.
- **Page Table Entry (PTE):** Contains information about the mapping between virtual and physical pages.
 - **Benefits of Paging**
	- **No External Fragmentation:** All pages and frames are of equal size, avoiding the fragmentation issue seen with segmentation.
	- **Simplified Allocation:** The OS allocates free page frames as needed without worrying about the size of segments or how memory grows.
----
## 18.2 - Where Are Page Tables Stored?
### Problem with Large Page Tables
- **Page tables** can become **very large**, especially for typical **32-bit address spaces** with 4KB page sizes:
    - Virtual address space splits into:
        - **20-bit Virtual Page Number (VPN)**.
        - **12-bit offset** (for 4KB pages).
    - A **20-bit VPN** means there are **2^20 (1 million) possible translations**.
    - Each **Page Table Entry (PTE)** needs **4 bytes** to store the translation and related information.
    - **Memory requirement per page table**: 4MB.
- **For 100 processes**:
    - The OS would need **400MB of memory** just for page tables.
    - This is a significant amount, even on modern systems with gigabytes of memory.
- Due to their large size, **page tables** are **not stored on-chip** in the **MMU**. Instead, they are stored in **physical memory**, which the OS manages.
- The OS may even **virtualize its own memory**, allowing page tables to be stored in **virtual memory** and even **swapped to disk** when necessary.
### Efficient Page Table Management
- As page tables are large, efficient management is required.
- While **page tables** are stored in **physical memory**, modern systems use various techniques to reduce the overhead of managing and storing page tables (e.g., hierarchical or multi-level page tables, which will be covered in future lessons).
- **Page tables** grow **very large**, especially for large address spaces.
- Storing page tables in memory for **multiple processes** can consume a significant amount of memory, requiring the OS to carefully manage page tables.
- While **modern hardware** doesn't store page tables directly on-chip, it uses **main memory** to store page tables, ensuring efficient address translation while conserving on-chip resources.
----
## 18.3 - Whatâ€™s Actually In The Page Table?
- The **page table** maps **virtual addresses** (specifically, **virtual page numbers (VPNs)**) to **physical addresses** (specifically, **physical frame numbers (PFNs)**).
- **Simple Structure:** The **linear page table** is the simplest form: an **array** where the **OS indexes by the VPN** to find the **PTE** that holds the translation to the **PFN**.
### Key Contents of Page Table Entries (PTEs)
- **Valid Bit:**
    - Indicates if the translation for a page is valid.
    - Used for **sparse address spaces**: Unused pages (between code, heap, and stack) are marked invalid, avoiding unnecessary memory allocation.
    - If the process tries to access an **invalid** page, it generates a **trap to the OS**, leading to process termination.
- **Protection Bits:**
    - Define whether the page can be **read from**, **written to**, or **executed**.
    - **Access violations** generate a **trap** to the OS.
- **Present Bit:**
    - Indicates if the page is currently in **physical memory** or has been **swapped to disk**.
    - Useful for handling address spaces larger than physical memory.
- **Dirty Bit:** Tracks whether the page has been **modified** since it was loaded into memory.
- **Reference/Accessed Bit:**
    - Tracks whether a page has been **accessed**.
    - Useful in **page replacement** to identify frequently-used pages.
### Example PTE: x86 Architecture
- **x86 Page Table Entry** (PTE) contains:
    - **Present Bit (P)**: Indicates if the page is in memory.
    - **Read/Write Bit (R/W)**: Determines if the page can be written to.
    - **User/Supervisor Bit (U/S)**: Controls if user-mode processes can access the page.
    - **Cache Control Bits (PWT, PCD, PAT, G)**: Determine hardware caching behavior for the page.
    - **Accessed Bit (A)**: Tracks if the page was accessed.
    - **Dirty Bit (D)**: Tracks if the page was modified.
    - **Page Frame Number (PFN)**: Points to the actual location in physical memory.
-----
## 18.4 -  Paging: Also Too Slow
- **Translation Steps:**
    - When accessing memory (e.g., `movl 21, %eax`), the system must:
        1. **Translate the virtual address** (e.g., 21) to a **physical address** (e.g., 117).
        2. Fetch the corresponding **Page Table Entry (PTE)** from the page table.
        3. Use the **Virtual Page Number (VPN)** and the **Page Table Base Register** to locate the PTE.
        4. Combine the **Physical Frame Number (PFN)** and **offset** to generate the final physical address.
### Steps in Translation Process
- **VPN Extraction:**
    - Extract **VPN** from the virtual address using a **VPN mask** and shift operation.
    - For example: Virtual address `21` (binary `010101`) -> VPN = `01` (virtual page 1).
- **Address Calculation:**
    - The **PTE address** is calculated by adding the **VPN** to the **Page Table Base Register**.
    - **PFN** is extracted from the PTE, then **concatenated** with the offset to generate the final physical address.
### Performance Issue
- **Extra Memory Access:**
    - Every memory reference requires one additional memory access to retrieve the page table entry (PTE).
    - This overhead can **slow down** the system significantly, potentially by **a factor of two or more**.
- **Performance Overhead:** Paging requires extra memory references, leading to slower access times.
- **Memory Usage:** Page tables consume a large amount of memory, especially in systems with large address spaces.
-----
