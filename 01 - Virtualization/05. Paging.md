# Reading Materials
[**Paging: Introduction**](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/vm-paging.pdf)
[**Paging: Faster Translations (TLBs)**](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/vm-tlbs.pdf)
[**Paging: Smaller Tables**](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/vm-smalltables.pdf)

----
# Paging: Introduction
### Two Approaches to Space Management
- **Variable-Sized Allocation (Segmentation):**
    - Divides memory into **variable-sized segments** (e.g., code, heap, stack).
    - **Problem:** This approach can lead to **external fragmentation**, making memory allocation harder over time as free space becomes non-contiguous.
- **Fixed-Sized Allocation (Paging):**
    - **Paging** is the second approach that solves space management problems by dividing memory into **fixed-sized pieces**.
    - Paging avoids fragmentation by dividing both virtual and physical memory into **fixed-sized units**.
### Introduction to Paging
- **Basic Idea:**
    - Paging divides a process's **virtual address space** into **fixed-size units** called **pages**.
    - Correspondingly, **physical memory** is divided into **page frames**, each of which can hold a single virtual page.
- **Key Terms:**
    - **Page:** A fixed-sized block of virtual memory.
    - **Page Frame:** A fixed-sized block of physical memory.
### CRUX: How to Virtualize Memory with Pages
- The challenge in paging is to efficiently manage the mapping between **virtual pages** and **physical page frames**.
- The OS must ensure that paging **minimizes overhead** in both **space** (memory usage for tracking pages) and **time** (time taken to translate virtual addresses to physical addresses).
-----
## 18.1 - A Simple Example And Overview
### Paging Process
- **Advantages of Paging:**
    - **Flexibility:** Pages from the virtual address space can be placed in any available page frame in physical memory, without assumptions about memory layout.
    - **Simplified Memory Management:** OS keeps a list of free page frames and allocates any available frames as needed.
- **Page Table:**  A **per-process** data structure that keeps track of where each **virtual page** is located in **physical memory**.
### Address Translation
- **Virtual Address Breakdown:** The virtual address space is 64 bytes (6 bits), so a virtual address is split into two parts:
	- **Virtual Page Number (VPN):** Top 2 bits for the page number.
	- **Offset:** Bottom 4 bits for the location within the page.
- **Example Translation:**
    - Process tries to load data from **virtual address 21**.
    - Virtual address **21** in binary is `010101`:
        - **VPN = 01** (virtual page 1).
        - **Offset = 0101** (the 5th byte in the page).
    1. The **page table** is consulted to translate VPN 1. The page table indicates that **virtual page 1** is in **physical frame 7**.
    2.  Replace VPN 1 with **PFN 7**.
    3. Combine the **PFN** and the **offset**. The result is the physical address **1110101** (decimal 117).
### Key Concepts
- **Page Table Storage:** The OS stores a page table for each process, mapping virtual pages to physical page frames.
- **Page Table Entry (PTE):** Contains information about the mapping between virtual and physical pages.
 - **Benefits of Paging**
	- **No External Fragmentation:** All pages and frames are of equal size, avoiding the fragmentation issue seen with segmentation.
	- **Simplified Allocation:** The OS allocates free page frames as needed without worrying about the size of segments or how memory grows.