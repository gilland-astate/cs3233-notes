#  Reading Materials
[Scheduling: Introduction](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/cpu-sched.pdf)
[Scheduling: The Multi-Level Feedback Queue](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/cpu-sched-mlfq.pdf)
[Summary Dialogue on CPU Virtualization](https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/Book/cpu-dialogue.pdf)

----
# Scheduling: Introduction
- Scheduling in computer systems has roots in operations management, as both fields aim to efficiently manage tasks or processes.
- The challenge is developing an effective **scheduling policy** that optimizes CPU usage. Key considerations include:
	- **Assumptions:** What are the conditions or constraints in the system?
	- **Metrics:** What criteria (e.g., efficiency, fairness, response time) should the policy optimize?
	- **Approaches:** What strategies have been historically used in early computer systems to guide scheduling decisions?
-----
## 7.1 - Workload Assumptions
- To develop effective scheduling policies, we need to define the **workload**—the characteristics of processes (jobs) running in the system.
- These assumptions simplify the initial exploration of scheduling policies, though they may not reflect real-world scenarios.
### Simplifying Assumptions
- **Assumption 1: Equal Job Run Times**: All jobs in the system are assumed to run for the same amount of time.
- **Assumption 2: Simultaneous Job Arrival**: All jobs are assumed to arrive at the system at the same time.
- **Assumption 3: No Preemption (Run to Completion)**: Once a job starts, it runs to completion without interruption or preemption.
- **Assumption 4: CPU-bound Jobs**: Jobs are assumed to use only the CPU and perform no I/O operations.
- **Assumption 5: Known Job Run Times**: The run-time of each job is known in advance, giving the scheduler complete knowledge of how long each job will take.
### Unrealistic Assumptions
- While these assumptions simplify policy design, they are not realistic in real-world systems.
    - **Example:** Knowing the exact run-time of each job is not feasible, as it would require the scheduler to be omniscient.
- As scheduling policies evolve, these assumptions will be relaxed to better reflect the complexities of real workloads.
- The goal is to eventually develop a **fully-operational scheduling discipline** that can handle more realistic scenarios.
-----
## 7.2 - Scheduling Metrics
- Metrics allow us to evaluate and compare different scheduling policies by providing a way to measure performance.
### Turnaround Time
- **Turnaround time** is the total time a job spends in the system, calculated as the time a job completes minus the time it arrived.
$$T_{turnaround} = T_{completion} − T_{arrival}$$
- **Simplified Case:** We assume all jobs arrive at the same time (Tarrival = 0), the formula simplifies to: $T_{turnaround} = T_{completion}$
- **Primary Metric:** Turnaround time is a **performance metric** that helps us evaluate how quickly jobs complete in a given scheduling policy.
- **Fairness Metric:**
    - Another important metric in scheduling is **fairness**, which ensures that all jobs get a chance to run without significant delay.
    - One example of measuring fairness is **Jain’s Fairness Index**.
- **Trade-off Between Performance and Fairness:** Scheduling policies often have to balance between **performance** and **fairness**.
	- A policy optimized for performance might favor some jobs, leaving others delayed, which reduces fairness.
----
## 7.3 - First in, First Out (FIFO)
- **FIFO (First In, First Out)** or **FCFS (First Come, First Served)** is a basic scheduling algorithm where jobs are executed in the order they arrive.
	- **Simplicity:** Easy to implement and understand.
	- **Order of Execution:** Jobs are processed in the order they enter the system.
### FIFO Scheduling with Equal Job Times
- Three jobs (A, B, and C) arrive at the same time (Tarrival = 0), each running for 10 seconds.
    - **Completion Times:**
        - A finishes at 10 seconds, B at 20 seconds, and C at 30 seconds.
    - **Average Turnaround Time:** $T_{turnaround} = (10 + 20 + 30) / 3 = 20$ seconds.
### FIFO Performance with Varying Job Lengths
- When jobs have different lengths, FIFO can perform poorly.
- A job (A) runs for 100 seconds, while jobs B and C run for 10 seconds each.
	- A runs for the full 100 seconds, causing B and C to wait in line.
	- **Average Turnaround Time:** $T_{turnaround} = (100 + 110 + 120) / 3 = 110$ seconds.
- **Problem:**
	- This creates the **convoy effect**, where shorter jobs are delayed by a long-running job, leading to high average turnaround times and poor system performance.
### Drawbacks
- FIFO works well when all jobs have similar execution times.
- It performs poorly when jobs have varying lengths, as longer jobs block shorter jobs from executing.
- **Challenge:** How can we improve scheduling algorithms to handle jobs with different lengths more efficiently and avoid the convoy effect?
-----
## 7.4 - Shortest Job First (SJF)
- **SJF (Shortest Job First)** is a scheduling policy where the shortest job is executed first, followed by the next shortest, and so on.
    - **Goal:** To minimize average turnaround time by prioritizing shorter jobs over longer ones.
### SJF Scheduling to Improve over FIFO
- Three jobs (A, B, and C) arrive at the same time, but A runs for 100 seconds, while B and C run for 10 seconds each.
- **SJF Schedule:** Instead of running A first, SJF runs B and C first, significantly reducing the average turnaround time.
- **Results:**
	- Turnaround time with FIFO: 110 seconds.
	- Turnaround time with SJF: $T_{turnaround} = (10 + 20 + 120) / 3 = 50$ seconds.
### SJF Performance
- **Optimality:**  Under the assumption that all jobs arrive at the same time, SJF is **optimal** for minimizing average turnaround time.
- **Improvement:** SJF often performs **much better** than FIFO, especially when job lengths vary.
### Challenges When Relaxing Assumptions
- In real-world systems, jobs do not arrive all at once but at different times.
- A arrives at t = 0 and runs for 100 seconds, while B and C arrive at t = 10 and each run for 10 seconds.
- **SJF Problem:** Despite B and C arriving shortly after A, they are forced to wait until A finishes, leading to a **convoy problem** similar to FIFO.
	- **Turnaround Time:** (100 + (110 − 10) + (120 − 10)) / 3 = 103.33 seconds.
### Limitations of SJF
- **Convoy Problem:** Even with SJF, longer jobs that arrive earlier can delay shorter jobs that arrive later, leading to inefficiencies and high turnaround times.
- **Challenge:** How can a scheduler adapt to jobs arriving at different times while maintaining efficiency? This requires further refinement of scheduling policies.
-----
## 7.5 - Shortest Time-to-Completion First (STCF)
- **STCF (Shortest Time-to-Completion First)**, also known as **Preemptive Shortest Job First (PSJF)**, allows the scheduler to preempt the current job and switch to a new job with the shortest remaining time to completion.
	- **Key Mechanism:** Whenever a new job arrives, the scheduler compares the remaining times of all jobs (including the new one) and runs the job with the least remaining time.
### Problem with Non-Preemptive SJF
- In the **non-preemptive** Shortest Job First (SJF) algorithm, jobs must run to completion once started, which can lead to inefficiencies when shorter jobs arrive after longer ones.
- **Solution:** To improve scheduling efficiency, **preemption** can be introduced to allow the scheduler to interrupt a long-running job when shorter jobs arrive.
### Using STCF to Improve over SJF
- Job A arrives at t = 0 and runs for 100 seconds, while jobs B and C arrive at t = 10 and each need to run for 10 seconds.
- **With STCF:** When B and C arrive, the scheduler **preempts** job A and runs B and C first. After B and C complete, the scheduler resumes job A.
- **Results:**
    - **Turnaround Time:**
        - Turnaround time with SJF: 103.33 seconds.
        - Turnaround time with STCF: $T_{turnaround} = (120 − 0) + (20 − 10) + (30 − 10) / 3 = 50$ seconds.
### Benefits of STCF
- **Optimality:** STCF is **optimal** in terms of minimizing turnaround time, just as SJF is optimal when all jobs arrive at the same time.
- **Preemption:** By allowing preemption, STCF avoids the **convoy effect** seen in non-preemptive schedulers like SJF and FIFO, where long-running jobs block shorter jobs.
- **Improved Efficiency:** STCF ensures that jobs with shorter remaining times are prioritized, improving overall system performance and reducing average turnaround times.